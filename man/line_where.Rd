% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/line_where.R
\name{line_where}
\alias{line_where}
\alias{lines_after}
\title{Identify an individual line in a sequence of commands}
\usage{
line_where(ex, ..., message = "No such line found.")
}
\arguments{
\item{ex}{a \code{"checkr_test"} object for instance as made by for_checkr()}

\item{...}{passif/failif/insist tests specifying the kind of line we want. The messages associated with
each test can have moustaches written in terms of F, Z, V, or E.}

\item{message}{A character string message to give if no acceptable line is found.}
}
\value{
A \code{"checkr_test"} result which is either a pass, fail, or OK.
}
\description{
The tests are written in terms of pronouns
\itemize{
\item F the function at the highest level (but with assignment removed)
\item Z the name being bound to the line's value by assignment. ("" if no assignment.)
\item V the value produced by the line.
\item E the expression itself (but with assignment removed)
}
}
\details{
Testing starts with the first test in \code{...}. Each test, in turn, can produce a definitive pass or fail result, at which point
testing is complete. But tests can also produce indefinite results, in which case testing moves on to the next test (if any).
If there is not a definitive result from the tests, the return

If \code{passif()} or \code{failif()} are used and the test is \code{TRUE}, no further testing is performed. Similarly,
if \code{insist()} is used and the test is \code{FALSE}, no further testing is performed. If none of these conditions
applies, \code{line_where()} progresses to the next of the tests in \code{...}. If none of the tests produce a definitive
result, \code{line_where()} will return an OK result.

The \code{ex} argument is a \code{"checkr_test"} object. If that input object is a fail, \code{line_where()} immediately returns
that input: none of the tests are performed. This allows test results to be cascaded.

Some important details about what types of objects F, Z, V, and E will be. V and E are straightforward: V will
always be the kinds of thing computed by the line, e.g. a vector, dataframe, and so on. E will always be
a language expression (minus the assignment, if any), and F will always be a character string. But Z is a name and character strings respectively.
\enumerate{
\item \code{x <- sin(y^2)}, F will be a character string, in this case, \code{"sin"}. Z will also be a character string, that is \code{"x"}. Keep in mind that
the R expression \code{sin} does not produce a name, it produces a value which happens to be the function that calculates sines.
\item \code{y <- 1:4; y[3] <- y[2]}, F will again be a \emph{name}, because indexing is a function call in R.
(In this example, the name is \code{as.name("[")}.) Z will again be a character string, in this case \code{"y[3]"}. You might
think it should be a call, because \code{quote(y[3])} is a call. But whatever is to the left of \code{<-} gets turned into a character
string.
}

[")\code{.) Z will again be a character string, in this case}"y\link{3}: R:%22)%60.)%20Z%20will%20again%20be%20a%20character%20string,%20in%20this%20case%20%60%22y[3
\link{3}: R:3
}
\examples{
ex <- for_checkr(quote({x <- 2; y <- x^3; z <- y + x}))
line_where(ex, insist(F == "^"), message = "Didn't find exponentiation")

}
